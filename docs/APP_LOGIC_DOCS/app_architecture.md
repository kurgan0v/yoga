# Архитектура приложения: Детальное описание

## Общая архитектура

Yoga App - это Telegram Mini App, построенное на следующих технологиях и принципах:

1. **Frontend**:
   - React.js + TypeScript для UI компонентов
   - Next.js для SSR и маршрутизации
   - TailwindCSS для стилизации
   - Telegram Web App API для интеграции с Telegram

2. **Backend**:
   - Supabase для базы данных, аутентификации и хранения
   - PostgreSQL в качестве основной базы данных
   - REST API для взаимодействия с клиентом
   - Serverless функции для специфичной бизнес-логики

3. **Хранение данных**:
   - PostgreSQL для реляционных данных
   - Supabase Storage для медиафайлов
   - Redis для кеширования (опционально)

4. **Интеграции**:
   - Telegram Bot API для уведомлений
   - Telegram Web App API для встраивания в Telegram

## Структура приложения

### Основные модули

1. **Авторизация и профиль**
   - Интеграция с Telegram для получения данных пользователя
   - Управление профилем
   - Отслеживание прогресса (До/После)

2. **Квиз для подбора практик**
   - Многоступенчатый квиз для выбора типа практики
   - Алгоритм подбора практик на основе предпочтений
   - Сохранение истории выборов

3. **Библиотека практик**
   - Каталогизация всех доступных материалов
   - Фильтрация и поиск
   - Управление избранным

4. **Календарь**
   - Планирование занятий
   - Уведомления о событиях
   - Управление личным расписанием

5. **Плееры**
   - Видео-плеер для телесных и дыхательных практик
   - Аудио-плеер для медитаций
   - Таймер для самостоятельных практик

### Frontend архитектура

#### Структура директорий

```
src/
├── components/              # Компоненты React
│   ├── common/              # Общие компоненты
│   ├── layout/              # Компоненты макета
│   ├── quiz/                # Компоненты квиза
│   ├── library/             # Компоненты библиотеки
│   ├── calendar/            # Компоненты календаря
│   ├── profile/             # Компоненты профиля
│   └── players/             # Компоненты плееров
├── pages/                   # Страницы Next.js
│   ├── index.tsx            # Главная страница
│   ├── quiz/                # Страницы квиза
│   ├── library/             # Страницы библиотеки
│   ├── calendar/            # Страницы календаря
│   ├── profile/             # Страницы профиля
│   └── api/                 # API роуты
├── context/                 # React контексты
│   ├── UserContext.tsx      # Контекст пользователя
│   ├── QuizContext.tsx      # Контекст состояния квиза
│   └── PlayerContext.tsx    # Контекст плееров
├── hooks/                   # Кастомные хуки
├── services/                # Сервисы для работы с API
│   ├── api.ts               # Базовый клиент API
│   ├── supabase.ts          # Клиент Supabase
│   └── telegram.ts          # Интеграция с Telegram
├── utils/                   # Утилиты и хелперы
├── styles/                  # Глобальные стили
└── types/                   # TypeScript типы
```

#### Ключевые компоненты

1. **App**
   - Корневой компонент приложения
   - Подключение контекстов
   - Базовая маршрутизация

2. **Layout**
   - Верхний навигационный бар
   - Нижний таб-бар
   - Контейнер для контента

3. **Квиз**
   - Компоненты для каждого шага квиза
   - Компоненты выбора (кнопки, радио-кнопки)
   - Индикаторы прогресса

4. **Плееры**
   - Видео-плеер с кастомными контролами
   - Аудио-плеер для медитаций
   - Таймер с визуализацией прогресса

5. **Профиль**
   - Компоненты отображения информации пользователя
   - Компоненты загрузки и отображения фото

### Backend архитектура

#### Supabase структура

1. **База данных**
   - Таблицы для пользователей, материалов, событий и т.д.
   - Триггеры для автоматизации действий
   - Политики безопасности (RLS)

2. **Аутентификация**
   - Кастомная аутентификация через Telegram
   - Управление сессиями
   - Проверка JWT токенов

3. **Хранилище**
   - Бакеты для медиафайлов
   - Политики доступа
   - CDN для быстрой доставки

4. **Edge функции**
   - Обработка логики квиза
   - Генерация рекомендаций
   - Отправка уведомлений

#### API Endpoints

1. **Пользователи**
   - `/api/user/profile` - получение/обновление профиля
   - `/api/user/progress` - управление прогрессом
   - `/api/user/stats` - статистика пользователя

2. **Квиз**
   - `/api/quiz/options` - получение вариантов для квиза
   - `/api/quiz/submit` - отправка ответов
   - `/api/quiz/result` - получение результата

3. **Библиотека**
   - `/api/library/materials` - список материалов
   - `/api/library/favorites` - управление избранным
   - `/api/library/categories` - категории материалов

4. **Календарь**
   - `/api/calendar/events` - управление событиями
   - `/api/calendar/participation` - участие в событиях

## Потоки данных

### Авторизация пользователя

1. Пользователь открывает Mini App в Telegram
2. Telegram предоставляет данные пользователя через WebApp API
3. Приложение проверяет подлинность данных через хеш
4. Создается или обновляется запись в таблице users
5. Генерируется сессия пользователя (JWT токен)

### Процесс выбора практики через квиз

1. Пользователь начинает квиз с главной страницы
2. Каждый шаг квиза сохраняется в QuizContext
3. На последнем шаге данные отправляются на сервер
4. Сервер фильтрует материалы согласно выбранным параметрам
5. Пользователю возвращается подходящая практика
6. Выбор сохраняется в истории

### Воспроизведение практики

1. Пользователь выбирает практику (через квиз или библиотеку)
2. Загружаются данные практики из Supabase
3. Инициализируется соответствующий плеер (видео, аудио, таймер)
4. Начинается отслеживание прогресса практики
5. По завершении обновляется статистика пользователя

## Интеграция с Telegram

### Telegram Web App API

```typescript
// Инициализация Telegram Web App
const tg = window.Telegram.WebApp;

// Получение данных пользователя
const user = tg.initDataUnsafe?.user;

// Настройка интерфейса
tg.expand(); // Развернуть на весь экран
tg.setHeaderColor('#FFFFFF'); // Установить цвет шапки

// Завершение работы
tg.close(); // Закрыть приложение
```

### Telegram Bot API для уведомлений

```typescript
// Отправка уведомления пользователю
async function sendNotification(telegramId: number, message: string) {
  const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      chat_id: telegramId,
      text: message,
      parse_mode: 'HTML',
    }),
  });
  
  return response.json();
}
```

## Управление состоянием

### React Context API

Основной способ управления глобальным состоянием - React Context:

1. **UserContext** - данные пользователя и авторизация
2. **QuizContext** - состояние процесса выбора практики
3. **PlayerContext** - состояние плееров и их настройки

### Local Storage

Для персистентности данных между сессиями используется localStorage:

1. Кеширование данных пользователя
2. Сохранение предыдущих выборов в квизе
3. Настройки плееров (громкость, скорость воспроизведения)

### Server State

Для управления серверным состоянием используется React Query:

1. Кеширование ответов API
2. Фоновое обновление данных
3. Управление состоянием загрузки и ошибок

## Взаимодействие между модулями

### Общие паттерны

1. **Pub/Sub** - через кастомные события для слабого связывания компонентов
2. **Dependency Injection** - через React Context
3. **Module Pattern** - для инкапсуляции логики

### Примеры взаимодействия

1. **Квиз -> Плеер**
   ```typescript
   // В компоненте квиза
   const { setSelectedPractice } = useContext(PlayerContext);
   
   // После получения результата квиза
   const handleQuizComplete = (result) => {
     setSelectedPractice(result.practice);
     router.push('/player');
   };
   ```

2. **Библиотека -> Календарь**
   ```typescript
   // В компоненте библиотеки
   const { addEventToCalendar } = useCalendar();
   
   // При выборе добавления в календарь
   const handleAddToCalendar = (practice) => {
     addEventToCalendar({
       title: practice.title,
       start_time: selectedDate,
       end_time: new Date(selectedDate.getTime() + practice.duration * 1000),
       material_id: practice.id
     });
   };
   ```

## Оптимизация производительности

### Frontend оптимизации

1. **Code Splitting** через динамические импорты React
2. **Мемоизация** для предотвращения лишних рендеров
3. **Lazy Loading** для изображений и тяжелых компонентов
4. **Префетчинг** для улучшения воспринимаемой производительности

### Backend оптимизации

1. **Кеширование** часто запрашиваемых данных
2. **Индексы** в базе данных для быстрого поиска
3. **Пагинация** для больших наборов данных
4. **Предзагрузка связанных данных** для уменьшения количества запросов

## Безопасность

### Аутентификация

1. Проверка подлинности данных Telegram через хеш
2. JWT токены для API запросов
3. Проверка срока действия токенов

### Авторизация

1. Row Level Security (RLS) в Supabase
2. Проверка прав доступа в API endpoints
3. Защита от CSRF атак

### Защита данных

1. Шифрование чувствительных данных
2. Валидация входных данных
3. Защита от инъекций SQL
4. Безопасные настройки CORS

## Процесс развертывания

### CI/CD пайплайн

1. **Сборка** - компиляция TypeScript, сборка Next.js
2. **Тестирование** - запуск unit и интеграционных тестов
3. **Деплой** - развертывание на Vercel/Railway

### Среды

1. **Development** - для разработки и тестирования
2. **Staging** - для предпродакшн тестирования
3. **Production** - для конечных пользователей

### Мониторинг

1. **Логирование** - сбор логов об ошибках и действиях пользователей
2. **Аналитика** - отслеживание использования приложения
3. **Алерты** - уведомления о проблемах в системе

## Заключение

Архитектура приложения спроектирована с учетом современных практик разработки, обеспечивая:

1. **Масштабируемость** - способность обрабатывать растущее количество пользователей
2. **Поддерживаемость** - четкое разделение ответственности между компонентами
3. **Расширяемость** - возможность легко добавлять новые функции
4. **Производительность** - оптимизация для быстрой работы
5. **Безопасность** - защита данных пользователей 